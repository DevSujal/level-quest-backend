<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=2.0" />
    <title>Document</title>
  </head>
  <body>
    <script type="text/javascript">
      // var x = 100;

      // if(true) { // non lexical scope
      //     var x = 10 // var statement in non lexical scope hoisting
      // }

      // // non lexical scope condition statemtents and loops

      // console.log(x);

      // function abc() {
      //     var y = 50
      //     // functions and objects are called lexical scope
      //     // in these var statement is not been hoisted
      // }
      // abc()

      // console.log(y)

      // there are two different styles are declaring functions
      // 1. functions declaration hoeisting -> function abc() {}
      // 2. function expressions -> var abc = function() {}

      // b = function () { // function expression b is just an identifier who knows the address of the anonymous function
      //     console.log("function b executed")
      // }
      // b();
      // b = function () {
      //     console.log("function b executed")
      // }

      // scope chain augmentation

      // var color = "blue"
      // function changeColors() {
      //     var anotherColor = "red"

      //     function swapColors() {
      //         var tempColor = anotherColor; // anotherColor identifier search in the scope chain [swap Colors, changeColors, global] -> order of scopes -> sca -> scope chain augmentation
      //         // activation object the first scope in the scope chain
      //         anotherColor = color;
      //         color = tempColor;
      //     }

      //     swapColors()
      // }

      // changeColors()

      // console.log("color is now " + color)

      // var x = 100 // premitive type cannot be extented
      // x.a = 500
      // console.log(x)
      // console.log(x.a)

      // two refrence types functions and objects

      // obj1 = new Object()

      // obj1.c = "new value for c"

      // console.log(obj1.c)

      // var a = 500
      // y = a // refered by value
      // console.log(a) // 500
      // console.log(y) // 500
      // a=1000
      // console.log(a) // 1000
      // console.log(y) // 500

      // obj1 = new Object()

      // obj1.a = 750

      // obj2 = obj1

      // console.log(obj1.a) // 750
      // console.log(obj2.a) // 750

      // obj2.b = 250

      // console.log(obj1.b) // 250
      // console.log(obj2.b) // 250

      // function f() {
      //     var x = 100;

      //     with(document.location) { // with statement is only conditional statement with lexical scope thats wht x is not hoesting
      //         var x = 500
      //     } // as on the modern day with statement is antipattern
      //     console.log(x) // [with, f(), window] -> with statment will attach itself in front of the scope chaining // 500
      // }
      // f()

      //   function Person() { // the brackets are constructor {} here
      //         this.x = 100; // this keyword previledged available to only to instances to the function but not public
      //         this.y = 200;

      //         var z = 300

      //   }

      // //   var vs public vs this
      // // var keyword makes class or function variables private cannot use it from instance
      // // we can also do these using removing var but then it makes it public
      // // this keyword makes private but we can use it from instances

      //   var inst1 = new Person();

      //   /* inst1 {

      //     only a copy of a previledged method or variable have inside the inst1
      //     private entities will not go into that instance
      //     this.x
      //     this.y

      //   } */

      //   console.log(inst1.x);
      //   console.log(inst1.y);
      //   console.log(inst1.z);

      // function count(a, b) {
      //     // console.log(arguments[0] + arguments[1]) // arguments array always present in the function
      //     var c = a + b
      //     console.log(c)
      // }

      // count(10, 20)

      // function Person(name) {
      //     this.getName = function() {
      //         return name
      //     }

      //     this.setName = function(value) {
      //         name = value
      //     }
      // }

      // var person = new Person("sujal")

      // console.log(person.getName()) // sujal
      // person.setName("nimje")
      // console.log(person.getName()) // nimje
      // a previdged lives in the same scope as that of a private entity and exposes the private entities to the instances

      //   function createFunction() {
      //     var result = new Array();

      //     for (var i = 0; i < 10; i++) {
      //       result[i] = (function (num) {
      //         return function() { return num};
      //       })(i)
      //     }

      //     return result;
      //   }

      //   var funcs = createFunction();

      //   for (var func of funcs) {
      //     document.write(func() + "</br>");
      //   }

      // nested function is closure

      // var name = "the window"

      // var object = {
      //     name : "my object",

      //     getNameFunc : function() {
      //         var x = this // thats why we took these here so that we can point to object scope
      //         // these keyword is a relative refrence where x is a absolute refrence
      //         return function() {
      //             return x.name // if we use these here then actually it is pointing to the window object
      //         }
      //     }
      // }

      // console.log(object.getNameFunc()())

      // recursion

      // function factorial(num)  {
      //     if(num <= 1) {
      //         return 1;
      //     }else return num * factorial(num-1)
      // }

      // var anotherFactorial = factorial

      // console.log(anotherFactorial(4))

        obj1 = new Object()

        obj2 = obj1
        delete obj1
        console.log(typeof obj2)

      // factory pattern
    //   function createPerson(name, age, job) {
    //     var o = new Object();
    //     o.name = name;
    //     o.age = age;
    //     o.job = job;
    //     o.sayName = function () {
    //       // biggest issue with factory pattern is duplication of methods with common functionalities
    //       console.log(this.name);
    //     };

    //     return o;
    //   }

    //   var person1 = createPerson("sujal", 29, "software developer");
    //   var person2 = createPerson("nimje", 27, "doctor");

    //   console.log(person1.sayName === person2.sayName);

    //   person1.sayName();
    //   person2.sayName();

    // constructor pattern
    </script>
  </body>
</html>
